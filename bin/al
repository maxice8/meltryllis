#!/bin/sh

#
# Global variables we use extensively in the script
#
#
AX_ABUILD=abuild
AX_ASUM="${AX_ASUM:=abuild}"
APORTSDIR="${APORTSDIR:=$PWD}"

#
# Simple usage that will be shown when the user uses a command in
# the wrong manner or when they call help
#
usage() {
	printf "%s <<h|e|b|n|c|mr|d|l|f|u|w|i>|<m> <repository>|<r> <package>> [package]\\n" "$(basename "$0")"
}

#
# This is used when the user calls -h this will be shown after showing
# the 'usage'
#
show_help() {
	echo "keys:
 h|help			  : show this help message
 e|edit			  : edit an APKBUILD
 b|build		  : build the package
 n|navigate		  : navigate the directory of the package
 c|checksum		  : regenerate checksum of the package
 mr|merge-request	  : create merge request for the package
 d|diff			  : diff various attributes of the package
 l|lint			  : run linting tools from atools on the package
 f|fix			  : run tools to automatically fix linting errors in the package
 m|move			  : move a package to another repo
 r|rename		  : rename a package
 u|unpack		  : unpack sources of the package and open the file manager in it
 w|work			  : unpack sources of the package, cd into it and init a git repo
 i|info			  : print information of the package
 p|pick			  : interactively cherry pick commits between 2 branches"
}

append_to_options() {
    printf '%s "%s" "%s" "%s"' "$1" "$2" "$3" "$4"
}

#
# Strip the alpine linux prefix from the branch, if the branch is 3.11-openldap
# then it will return openldap, if it doesn't have a prefix then do nothing
#
strip_al() {
    [ "$1" ] || return 1
    val="$(alpine-stable-prefix "$1")"
    if [ "$val" ]; then
        printf "%s\\n" "$1" | cut -d - -f 2-
    else
        printf "%s\\n" "$1"
    fi
}

#
# This is used before running any command that requires switching to
# the directory of the APKBUILD, almost all commands from abuild require
# the user to switch to it
#
run() {
    [ "$1" ] || [ "$2" ] || return 1
	pushd "$APORTSDIR"/"$1" >/dev/null 2>&1
	$2
	popd >/dev/null 2>&1
}

#
# Same as the run() function but run inside an ssh section in Alpine
#
run_ssh() {
    [ "$1" ] || [ "$2" ] || return 1
    ssh -tt Alpine "export PATH=$PATH; cd $APORTSDIR/$1 && $2"
}

#
# Helper function that returns a proper error code if the git tree is
# dirty
#
isclean() {
	git diff --quiet --exit-code
}

#
# Check if we were given any arguments, the first argument is always one
# of the options we match against for specific actions like 'e' to edit
# a package
#
# Argument ordering depends on the specific action called on the 1st argument
# but it will never do operations on more than 1 package at a time
#
# If no package name is given to us then rely in the branch name, if the user
# calls 'ax e' and the branch is called 'poppler' then we assume the user wants
# to edit the poppler package
#
if [ $# -lt 1 ]; then
    usage
    exit 1
fi

#
# Change our directory to APORTSDIR, we want to do all operations relative to
# it, some tools specifically assume we are in it and it is just good to cd into
# it ourselves so people can call this script from anywhere else
#
cd "$APORTSDIR" || {
    printf -- "failed to switch to %s\\n" "$APORTSDIR" 
    exit 1
}

#
# Define path here outside the scope of the next match because we will need to use
# it later, if we don't it define outside the scope it will be lost
#
path=""

#
# version holds the suffix we want when using abuild
#
version=""

#
# Store the first 3 arguments in these variables we manipulate
# we need it here outside otherwise they will not be changed
#
firstArg="$1"
secondArg="$2"
thirdArg="$3"

#
# This is a super-match that will match classes of actions that require the same
# setup actions, like automatically adding a missing argument and checking if the
# package in itself exists
#
case "$1" in
    e|edit|b|build|n|navigate|c|checksum|d|diff|mr|merge-request|l|lint|f|fix|u|unpack|w|work|i|info|p|pick)
		#
		# No package name given to us, rely on the branch name instead
		#
        if [ -z "$secondArg" ]; then
            secondArg="$(git branch --show-current)"
        fi
        
        #
        # Use alpine-stable-prefix to get the version
        #
        version="$(alpine-stable-prefix "$(git branch --show-current)")"

        #
        # Update AX_ASUM and AX_ABUILD to have the suffixes
        #
        if [ "$version" ]; then
            AX_ABUILD="$AX_ABUILD-$version"
        fi

		#
		# use strip_al to remove the Alpine Linux specific branch name
		# this will remove the stable version number before the package
		# eg: 3.11-openldap returns openldap
		#
        secondArg="$(strip_al "$secondArg")"
		
		#
		# The usage of find_repo is extremely convenient as it is
		# fast efficient, has good ordering (if there are 2 packages
		# of the same name, the only in the more important repo comes
		# first) and will return nothing if there is no packages instead
		# of needlessly polluting stderr
		#
		# Note that there is also no need to check if APKBUILD itself exists
		# as that is what find_repo does
		#
        path="$(find_repo "$secondArg")"
        if [ -z "$path" ]; then
			printerr no package named "'$secondArg'"
			exit 1
        fi
        ;;
    m|move)
		#
		# Check if we were given a repository as our 2nd argument
		#
        if [ -z "$secondArg" ]; then
			printerr Please pass a repository to move the package to
			exit 1
		fi

		#
		# No package name given to us, rely on the branch name instead
		#
        if [ -z "$thirdArg" ]; then
            thirdArg="$(git branch --show-current)"
        fi

		#
		# use strip_al to remove the Alpine Linux specific branch name
		# this will remove the stable version number before the package
		# eg: 3.11-openldap returns openldap
		#
		thirdArg="$(strip_al "$thirdArg")"

		#
		# The usage of find_repo is extremely convenient as it is
		# fast efficient, has good ordering (if there are 2 packages
		# of the same name, the only in the more important repo comes
		# first) and will return nothing if there is no packages instead
		# of needlessly polluting stderr
		#
		# Note that there is also no need to check if APKBUILD itself exists
		# as that is what find_repo does
		#
        path="$(find_repo "$thirdArg")"
        if [ -z "$path" ]; then
			printerr no package named "'$thirdArg'"
			exit 1
        fi

		#
		# Check if the repo we were given exists and if there already exists
		# a package there with the same name
		#
        if [ ! -d "$secondArg" ]; then
			printerr no repository named "'$secondArg'"
			exit 1
        fi

        
		if [ -f "$secondArg"/"$thirdArg"/APKBUILD ]; then
			printerr "There is already a package called '$thirdArg' in repository '$secondArg'"
			exit 1
        fi
        ;;
	r|rename)
		#
		# Check if we were given a package name as our first argument
		# this package name is the name of the package we will rename
		# the package to
		#
        if [ -z "$secondArg" ]; then
			printerr "Please pass a new name for the package"
			exit 1
		fi

		#
		# No package name given to us, rely on the branch name instead
		# this package name is different from the one above, this one
		# is the name of the package that will be renamed
		#
        if [ -z "$thirdArg" ]; then
            thirdArg="$(git branch --show-current)"
        fi

		#
		# use strip_al to remove the Alpine Linux specific branch name
		# this will remove the stable version number before the package
		# eg: 3.11-openldap returns openldap
		#
		thirdArg="$(strip_al "$thirdArg")"

		#
		# The usage of find_repo is extremely convenient as it is
		# fast efficient, has good ordering (if there are 2 packages
		# of the same name, the only in the more important repo comes
		# first) and will return nothing if there is no packages instead
		# of needlessly polluting stderr
		#
		# Note that there is also no need to check if APKBUILD itself exists
		# as that is what find_repo does
		#
		path=$(find_repo "$secondArg")
		if [ "$path" ]; then
			printerr there is already a package named "'$secondArg'"
			exit 1
		fi
esac

#
# Match the action, each action requires diferent argument parsing as they have
# different requirements, 'e' (edit an APKBUILD) requires nothing more than a
# package name while stuff like 'm' (move an APKBUILD to another REPOSITORY)
# require a repository to move to and a package name
#
case "$firstArg" in 
	e|edit)
		#
		# Open the APKBUILD in your favourite text editor
		#
		${EDITOR:-nvim} "$path"/APKBUILD
        ;;
	b|build)
		#
		# Construct an array with all the flags to be passed to abuild
		# this can be manipulated by the user by passing AX_BUILD_ARGS
		#
        flags="-r"
        if [ "$AX_ABUILD_ARGS" ]; then
            flags="$flags $AX_ABUILD_ARGS"
        fi
		
        #
        # Check if we have a valid binary for building the packages
        # this can happen in cases where we want to build from a branch
        # we didn't make a container yet
        #
        if ! command -v "$AX_ABUILD" >/dev/null 2>&1; then
            printerr "no binary for building the package tried: '$AX_ABUILD'"
            exit 1
        fi

		#
		# AX_LOG is a variable that can be set so the output of the build
		# process is logged to a temporary file
		#
        if [ "$AX_LOG" ]; then
			_mktemp="$(mktemp)"
 			run "$path" "$AX_ABUILD $flags" | tee "$_mktemp"
		else
			run "$path" "$AX_ABUILD $flags"
		fi
        ;;
	n|navigate)
		#
		# Open the file manager in the directory of the package
		#
		f "$path"
        ;;
	c|checksum)
		#
        # Check if we have a binary for doing checksum
		#
        if ! command -v "$AX_ASUM" >/dev/null 2>&1; then
            printerr "no binary for regenerating checksum, tried: '$AX_ASUM'"
            exit 1
        fi

		#
		# run the binary pointed by 'AX_ASUM' and ask it to regenerate the
		# checksum for the package
		#
		run "$path" "$AX_ASUM checksum"
        ;;
	mr|merge-request)
		#
		# Add the files of the package into the git staging and then commit them
		# rely on .githooks to produce a suitable commit message, then use mkmr
		# to create the merge request from the command-line
		#
		git add "$path"
		if ! git commit --no-edit; then
			printerr Failed to commit changes, the tree is dirty, please fix
			exit 1
		fi
        glab mr create -f -y
        ;;
    d|diff)
		#
		# run apkg-diff which will fetch the old packages and diff them
		# againast the new ones
		#
		output="$(run_ssh "$path" "apkg-diff size depend provides files")"
        printf -- "%s\\n" "$output" | less -r --quit-if-one-screen
        ;;
	l|lint)
		#
		# Run all linting tools from atools in the APKBUILD
		#
 		run "$path" "apkbuild-lint APKBUILD"
 		run "$path" "aports-lint APKBUILD"
 		run "$path" "secfixes-check APKBUILD"
        ;;
	f|fix)
		#
		# Run all linting tools from atools in the APKBUILD
		#
		run "$path" "apkbuild-fixer APKBUILD"
        ;;
	u|unpack)
		#
		# Use $AX_ASUM (the version of abuild that does not run a docker container)
		# to unpack the sources for us
		#
		if ! run "$path" "$AX_ASUM unpack"; then
			printerr "Failed to unpack sources for '$secondArg'"
			exit 1
		fi

        #
        # Source the APKBUILD, we need to get a few important variables
        #
		. "$path"/APKBUILD

		#
		# This variable hold the path to where the source code of the package was extracted
		# we will in the end of this function, open a file manager on it
		#
		workdir="$path"/src

        if [ "$builddir" ]; then
			#
			# We don't need to put a '/' here first because a normal definition of builddir
			# is "$srcdir"/foo-bar, the $srcdir won't be expanded and we will end with a
			# string that starts with '/' itself
			#
            workdir="${workdir}$builddir"
		else
            workdir="${workdir}/$pkgname-$pkgver"
		fi

		f "$workdir"
        ;;
	w|work)
		#
		# Use $AX_ASUM (the version of abuild that does not run a docker container)
		# to unpack the sources for us
		#
		if ! run "$path" "$AX_ASUM unpack"; then
			printerr "Failed to unpack sources for '$secondArg'"
			exit 1
		fi

		#
        # Source the APKBUILD so we get their nice variables
		#
		. "$path"/APKBUILD

		#
		# This variable hold the path to where the source code of the package was extracted
		# we will in the end of this function, open a file manager on it
		#
		workdir="$path"/src

        if [ "$builddir" ]; then
			#
			# We don't need to put a '/' here first because a normal definition of builddir
			# is "$srcdir"/foo-bar, the $srcdir won't be expanded and we will end with a
			# string that starts with '/' itself
			#
            workdir="${workdir}$builddir"
		else
            workdir="${workdir}/$pkgname-$pkgver"
		fi

		#
		# Push into the work directory given to us, we will pop out of it after we are
		# done
		#
		cd $workdir >/dev/null 2>&1 || return 1

		#
		# Initialize a git repository and add all files to it, then make an initial commit
		# this will allow us to easily create patches from any future changes
		#
		git init >/dev/null
		git add .
		git commit -m 'Start work' >/dev/null

		#
		# Start a temporary shell that allows users to do all the work
		# they need, default to ion if SHELL is not set in the environment
		#
        $SHELL

		#
		# As we have finished everything we pop out of the directory back into where the user
		# was
		#
		cd - >/dev/null 2>&1 || return 1
        ;;
	i|info)
		#
		# In the future, iopkg should be rewritten in rust, but it will suffice for
		# now
		#
		run $path iopkg
        ;;
	m|move)
		#
		# Check if we were given a path that ends with '/', it is not uncommon for
		# for people to use shell completion which will complete 'dir' to 'dir/'
		# the previous iteration of this (the one written in shell) would fail
		# if the path given to us had '/'
		#
        if printf "%s" "$secondArg" | grep -q '/$'; then
            secondArg="$(printf "%s" "$secondArg" | sed 's/.$//')"
		fi

		#
		# If the directory already exists then move all contents from inside
		# the directory we're moving from to it, otherwise move the directory
		# itself to the new location
		#
		if [ -d "$secondArg"/"$thirdArg" ]; then
			git mv -- "$path"/* "$secondArg"/"$thirdArg"
		else
			git mv -- "$path" "$secondArg"
		fi

		#
		# Use the isclean function to check if we operating in a dirty git tree
		# and if not then we can just push ahead and make a nice commit for the
		# user
		#
		# In this case use the $basename of the $parent of $path, $path is the
		# old path of the package at this point
		#
		if isclean; then
			env NOAPKBUILD_LINT=1 \
				NOAPORTS_LINT=1 \
				NOPKGVERCHECK=1 \
				git commit -m "$secondArg/$thirdArg: move from $(basename "${path%/*}")"
		fi
        ;;
	r|rename)
		#
		# The usage of find_repo is extremely convenient as it is
		# fast efficient, has good ordering (if there are 2 packages
		# of the same name, the only in the more important repo comes
		# first) and will return nothing if there is no packages instead
		# of needlessly polluting stderr
		#
		# Note that there is also no need to check if APKBUILD itself exists
		# as that is what find_repo does
		#
        old_path="$(find_repo "$thirdArg")"
		if [ -z "$old_path" ]; then
			printerr no package named "'$thirdArg'"
			exit 1
        fi

		#
		# Get the basename of the parent of the old path, this will give us the
		# repository, path is something like 'main/poppler', so getting the
		# basename of the parent means we get 'main'.
		#
        repo="$(basename "${old_path%/*}")"

		#
		# If the directory already exists then move all contents from inside
		# the directory we're moving from to it, otherwise move the directory
		# itself to the new location
		#
		if [ -d $repo/"$secondArg" ]; then
			git mv -- "$old_path"/* "$repo"/"$secondArg"
		else
			git mv -- "$old_path" "$repo"/"$secondArg"
		fi

		#
		# Try being nice to the user and automatically apply sed to change the
		# pkgname= variable from the old name to the new name. But do not mind
		# if it fails for any reason, the user can fix it later and amend the
		# commit
		#
		sed -e "s|^pkgname=.*|pkgname=$secondArg|g" -i "$repo"/"$secondArg"/APKBUILD

		#
		# Use the isclean function to check if we operating in a dirty git tree
		# and if not then we can just push ahead and make a nice commit for the
		# user
		#
		#
		if isclean; then
			env NOAPKBUILD_LINT=1 \
				NOAPORTS_LINT=1 \
				NOPKGVERCHECK=1 \
				git commit -m "$repo/$secondArg: rename from $thirdArg"
        fi
        ;;
    p|pick)
	#
	# We will need dialog(1) utility, check if we have an executable
	#
	if ! which dialog >/dev/null 2>&1; then
		printerr the dialog'(1)' utility is missing
		exit 1
    fi

	#
	# The source branch is the branch we are getting the commits from, most
	# of the time this branch is 'master' as we are backporting to from Edge
	# onto stable branches, be they bugfixes for community/ or security fixes
	# for main/
	#
	# If we were given a second argument, treat that as the branch we want
	# to source our commits from, otherwise assume we are using master
	#
    source_branch=master
    if [ -n "$thirdArg" ]; then
        source_branch="$thirdArg"
	fi

	#
	# The target branch is the branch we are on, it is the branch we want to
	# port the commits to
	#
    target_branch="$(git branch --show-current)"

	#
	# Check if we were not passed the same branch as both target and source
	# branches, there is no sense to backport from itself
	#
	if [ "$target_branch" = "$source_branch" ]; then
        printerr Both branches given are the same
		exit 1
	fi

	#
	# Show all commits between the target_branch and the source_branch that
	# modified the path given to us.
	#
	# We use --reverse so the list will come with the older commits on the top,
	# which should always be cherry-picked before the others
	#
	commits="$(git log --oneline --reverse "$target_branch".."$source_branch" -- $path)"

	#
	# Check if there is any output with the commits passed to us, if it is empty
	# then there is nothing to be backported
	#
	if [ -z "$commits" ]; then
		printerr no changes between "$target_branch" and "$source_branch" "for" "$path"
		exit 1
	fi

	#
	# Create an array that will hold all the options that are to be available
	# in our checkboxes which are composed of:
	# SHA1 - title - off
	#
	# SHA1 is the SHA of the commit in question, we use those in git cherry-pick
	# title is the title of the commit, the user must know these
	# off is passed to the dialog(1) utility and makes the option not ticked by
	#  default
	#

	#
	# The options array must be created here or it will go out of scope if done
	# inside the for-loop
	#
    options=""

	#
	# Iterate over all the commits, line-by-line
	#
    OLDIFS="$IFS"
    IFS="
" # Have newline as the splitting elemnt
	for line in $commits; do
        sha1="$(printf -- "%s\\n" "$line" | cut -d ' ' -f1)"
        title="$(printf -- "%s\\n" "$line" | cut -d ' ' -f2-)"
		#
		# Append the SHA1, title and off to the options array, the title
		# must be quoted otherwise it will be split into various elements
		# instead we must have a single element that is a string with
		# whitespace present
		#
        options="$(append_to_options "$options" "$sha1" "$title" off)"
	done
    IFS="$OLDIFS"

	#
	# Create a dialog with our options, the options picked by the user
	# will be present in the file .al-cherry-pick inside the XDG_RUNTIME_DIR
	# if one does not have that then just fail and let the user figure it out
	# XDG_RUNTIME_DIR is the best we have and it is not worth it to support
	# fallbacks for such a widely used feature
	#
	dialog \
		--colors \
		--keep-tite \
		--no-shadow \
		--no-mouse \
		--checklist "Pick commits for $path" \
		0 0 0 \
        "$options" 2>"$XDG_RUNTIME_DIR"/.al-cherry-pick

	# 	#
	# 	# Read the SHA1 of the commits picked by the user, use the @split method
	# 	# so they are split by whitespace
	# 	#
	# 	let commit = $(cat $XDG_RUNTIME_DIR/.al-cherry-pick)

	# 	#
	# 	# Check if any commits were picked via the dialog(1) interface
	# 	# this value will be empty if none are picked
	# 	#
	# 	if not exists -s commit
	# 		printerr No commits were picked for $path
	# 		exit 1
	# 	end

	# 	#
	# 	# Use the cherry-pick command from git, there will most likely be conflicts
	# 	# but those are none of our concerns, the user can fix those and --continue
	# 	# the cherry-pick.
	# 	#
	# 	# Use -x so that we will get a nice message pointing from where we backported
	# 	# the commit, only if there are no conflicts
	# 	#
	# 	for c in @split($commit)
	# 		git cherry-pick --strategy=recursive -X theirs -x $c
	# 	end
    ;;
	*)
		usage
		show_help
		exit 1
esac

exit 0
