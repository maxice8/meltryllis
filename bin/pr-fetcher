#!/bin/sh
if ! [ -d .git ]; then
	echo "Not in a git repo" >&2
	return 1
fi

# Clean up after our operations
cleanup() {
	# Clean up the temporary directory
	[ -n "$tempdir" ] && [ -d "$tempdir" ] && rm -rf "$tempdir"
	# Delete the branch we used
	if git rev-parse --verify "$pr_num" >/dev/null 2>&1; then
		git checkout -q master
		git branch -q -D "$pr_num"
	fi
}
trap cleanup EXIT

uuser="$(get-repo-config repo-owner)"
urepo="$(get-repo-config repo-name)"
ouser="$(get-repo-config origin-repo-owner)"
orepo="$(get-repo-config origin-repo-name)"

prfile="${XDG_RUNTIME_DIR:-'/tmp'}"/PRs-"$uuser"-"$urepo"

# Print a message to the user
msg() {
	printf -- "\\033[0;36m[ PLEASE WAIT ]\\033[0m $*\\n"
}

ask() {
	printf -- "\\033[0;33m[ PLEASE ANSWER ]\\033[0M $*\\n"
}

# List all APKBUILD files that have been added or modified in the given commit, trim
# files that do not actually exist
# NOTE: ideally --diff-filter should deal with only changed APKBUILDs since if a new
# APKBUILD is added we can just comment on the commit that adds it in full. But we
# need to check for when they are added when files are moved from one repo to another
changed_files() {
	for file in $(git diff-tree \
				  --no-commit-id \
				  --name-only -r --diff-filter=AM \
				  "$@" '**/APKBUILD'); do
	[ -f "$file" ] && echo $file
	done
}

annotate_commit() {
	local input= commit="$1" commitfile="$2"/"$1"

	while true; do
		# Show a fzf prompt with the commit navigable as a pager and get the output
		# of the query, either empty or the message to be added to the comments
		# TODO: make it work as a full pager, not matching fuzzy as we type, that is just annoying
		input="$(git show "$commit" | colordiff | fzf \
												  --layout reverse \
										 		  --ansi \
										 		  --print-query \
										 		  --no-hscroll \
										 		  --border \
										 		  --inline-info \
										 		  --no-clear \
										 		  --prompt="$commit > " \
												  | head -1)"

		printf "%s\\n"  "$input" >> "$commitfile"

		# Strip all empty lines	
		sed -i '/^$/d' "$commitfile"

		# Replace all newlines with '@@@' but restore the last one
		awk 1 ORS="@@@" "$commitfile" | sed "s|@@@$|\\n|" > "$commitfile"- && mv "$commitfile"- "$commitfile"

		# If no output was written on the prompt then the user wants to exit
		# restore the terminal and break out of the loop
		if [ -z "$input" ]; then
			tput rmcup
			break
		fi
	done
}

annotate_file() {
	local input= file="$1" filefile="$2"/"$1"

	# Create path to the file
	mkdir -p "${filefile%/*}"

	while true; do
		# Show a fzf prompt with the commit navigable as a pager and get the output
		# of the query, either empty or the message to be added to the comments
		# TODO: make it work as a full pager, not matching fuzzy as we type, that is just annoying
		input="$(cat -n "$file" | fzf \
								  --layout reverse \
								  --ansi \
								  --print-query \
								  --no-hscroll \
								  --border \
								  --inline-info \
								  --no-clear \
								  --prompt="$file > " \
								  | head -1)"

		printf "%s\\n"  "$input" >> "$filefile"

		# Strip all empty lines	
		sed -i '/^$/d' "$filefile"

		# Replace all newlines with '@@@' but restore the last one
		awk 1 ORS="@@@" "$filefile" | sed "s|@@@$|\\n|" > "$filefile"- && mv "$filefile"- "$filefile"

		# If no output was written on the prompt then the user wants to exit
		# restore the terminal and break out of the loop
		if [ -z "$input" ]; then
			tput rmcup
			break
		fi
	done
}

# If the user executed pr-fetcher-daemon binary or invokes with the
# first arg as daemon then we execute a PRs fetching daemon, hub pr list
# takes a very long time, so run it every 5 minutes
if [ "${0##*/}" = "pr-fetcher-daemon" ] || [ "$1" = "daemon" ]; then
	while true; do
		output=""
		output="$(hub pr list -f '(%i) (%NC) %t by %au%n')"
		[ -z "$output" ] && continue
		printf "%s\\n" "$output" > "$prfile"
		sleep 300
	done
fi

if [ ! -f "$prfile" ]; then
	echo "PRs file is not present, start pr-fetcher-daemon or run this program with daemon" >&2
	return 1
fi

# Ask the user to pick a PR using 'fzy'
# Remove the name of the user since you can't remove
# Remove users that don't want reviews that include
# linting and quality of APKBUILD improvments that
# are not directly related to the PR in hand, this
# can be revisited once proper linting is part of
# Alpine review process.
picked_pr="$(grep -v "by $ouser" < "$prfile" \
			 | grep -v 'by PureTryOut' \
			 | grep -v 'by 5paceToast' \
			 | fzy --lines="$(tput cols)")"

# If the user picked nothing then quit, this program can be used to check for PRs
[ -z "$picked_pr" ] && return 0

# Number of the PR as a whole integer, remove the () and # with tr
pr_num="$(printf "%s\\n" "$picked_pr" | cut -d ' ' -f1 | tr -d '()#')"
title="$(printf "%s\\n" "$picked_pr" | cut -d ' ' -f3- | sed 's| by .*||g')"

commits=""

# Check if we already reviewed the PR
msg Checking if "$pr_num" "($title)" was already reviewed
reviews="$(hub api \
		   /repos/${uuser}/${urepo}/pulls/${pr_num}/reviews)"

user="$(printf "%s\\n" "$reviews" \
		| jq --arg GITNAME "$ouser" \
		 -r '.[].user.login | select(.==$GITNAME)')"
state="$(printf "%s\\n" "$reviews" \
		| jq -r '.[].state')"
body="$(printf "%s\\n" "$reviews" \
		| jq -r '.[].body')"

if [ -n "$user" ]; then
	while true; do
		echo "Previous review found!"
		echo "PR number: $pr_num"
		echo "PR title: $title"
		echo "state: $state"
		echo "body: $body"
		read -p "make new review? " yn
		case $yn in
			[Yy]* |'') break ;;
			[Nn]* ) exit 0 ;;
			[Oo]* ) 
				echo "Opening in a browser"
				hub browse -- issues/$pr_num
				;;
			* ) echo "Please answer yes or no" ;;
		esac
	done
fi

# Check if the pr is already fetched, if not fetch it and checkout it
if git rev-parse --verify "$pr_num" >/dev/null 2>&1; then
	msg Switching to branch "$pr_num"
	gbr "$pr_num"
else
	# Check out the pr num with the name of the pr branch
	msg Fetching and checking out branch "$pr_num"
	hub pr checkout "$pr_num" "$pr_num" >/dev/null 2>&1 &
	msg Fetching commits for "$pr_num"
	commits="$(hub api \
			   /repos/${uuser}/${urepo}/pulls/${pr_num}/commits \
			   | jq -r '.[].sha' &)"
	wait
fi

if [ -z "$commits" ]; then
	msg Fetching commits from "$pr_num" "($title)"
	commits="$(hub api \
			   /repos/${uuser}/${urepo}/pulls/${pr_num}/commits \
			   | jq -r '.[].sha')"
fi

commitcount="$(printf "%s\\n" "$commits" | wc -l)"

# Comments to be given on the PR in regards to both, comments from the 2 above
# will be added here and displayed to the user
comments=""

files=""
for commit in $commits; do
	# Add file in a newline so we can operate on them with sort -u
	files="$files
$(changed_files $commit)"
done

# We don't want to operate on duplicate files, if 2 commits point to the same
# file like one that is updating and one that is making style changes are in the
# same PR, we don't want to open the APKBUILD twice
files="$(printf "%s\\n" "$files" | sort -u | sed '/^$/d')"
filecount="$(printf "%s\\n" "$files" | wc -l)"

# Temporary directory that holds the files that represents the comments and
# the commits
tempdir="$(mktemp -d)"

# Read comments for the PR until we have one that is just exit
while true; do

	# If we have only one commit then just go to it instead of asking the user
	# what commit he wants to look at
	if [ "$commitcount" -eq 1 ]; then
		annotate_commit "$commits" "$tempdir"
		break
	fi

	# If the user has less than 3 commits then set lines to 3 since we can't have
	# a lower value to that
	[ "$commitcount" -lt 3 ] && lines=3 || lines=$commitcount

	tput clear # Clear the terminal
	yn="$(git show $commits -s --pretty=oneline | fzy \
												  --lines="$lines" \
												  --prompt="pick a commit: ")"

	yn="$(printf "%s\\n" "$yn" | cut -d ' ' -f1)"

	case "$yn" in
		'') break ;; # This is reached with 'fzy' when the user presses ctrl-c
		*) annotate_commit "$yn" "$tempdir" ;; 
	esac
done

# Read comments for the PR until we have one that is just exit
while true; do

	[ -z "$files" ] && break

	# If there is only one file modified then just go to it instead of asking
	# the user which file he wants
	if [ "$filecount" -eq 1 ]; then
		annotate_file "$files" "$tempdir"
		break
	fi

	[ "$filecount" -lt 3 ] && lines=3 || lines=$filecount

	tput clear # Clear the terminal
	yn="$(echo "$files" | fzy \
						  --lines="$lines" \
						  --prompt="pick a file: ")"

	yn="$(printf "%s\\n" "$yn" | cut -d ' ' -f1)"

	case "$yn" in
		'') break ;; # This is reached if the user presses ctrl-c
		*) annotate_file "$yn" "$tempdir" ;; 
	esac
done

tput clear
msg Starting shell to work on \#$pr_num
sh -l || needsinput=1
tput clear
msg Finished shell work on \#$pr_num

# Iterate over all files in tempdir, sort so that commits come before
# filenames
for as in $(find "$tempdir" -type f -print | sort -t / -k 2); do
	relas="${as##*$tempdir/}" # Strip the temporary dir from the path
	[ -s "$file" ] && continue # Empty files can be ignored safely
	header="For $relas" # This is 'For <commit|filename>'
	inputs="$(cat "$as")"
	[ -z "$inputs" ] && continue # No comments, continue
	comments="${comments}${header}@@@\`\`\`@@@${inputs}@@@\`\`\`@@@"
done

if [ "$needsinput" -eq 1 ]; then
	msg Getting user input on \#$pr_num after shell tests
	${EDITOR:-vi}  "$tempdir"/.in-general
	
	# Get general comments from the user
	if [ -s "$tempdir"/.in-general ]; then
		header="general comments:"
		sed -i '/^$/d' "$tempdir"/.in-general
		inputs="$(awk 1 ORS="@@@" "$tempdir"/.in-general | sed "s|@@@$|\\n|")"
		comments="${comments}${header}@@@\`\`\`@@@${inputs}@@@\`\`\`@@@"
	fi
fi

if [ -z "$comments" ]; then
	msg Approving PR "$pr_num" "($title)"
	appr "$pr_num" LGTM
else
	msg "Requesting changes on $pr_num ($title) with the following comments
$(printf "%s\\n" "$comments" | sed 's|@@@|\
|g')"
	appr -r "$pr_num" "$comments"
fi

# Avoid using the 'dlbr' script since that also tries to remove a branch
# in the remote repo and we don't need that
msg Deleting branch "$pr_num"
git checkout -q master && git branch -q -D "$pr_num"
