#!/bin/sh
if ! [ -d .git ]; then
	echo "Not in a git repo" >&2
	return 1
fi

# Print a message to the user
msg() {
	printf -- "\\033[0;36m[ PLEASE WAIT ]\\033[0m $*\\n"
}

# List all APKBUILD files that have been added or modified in the given commit
changed_files() {
	git diff-tree \
		--no-commit-id \
		--name-only -r --diff-filter=AM \
		"$@" \
		'**/APKBUILD'
}

# If the user executed pr-fetcher-daemon binary or invokes with the
# first arg as daemon then we execute a PRs fetching daemon, hub pr list
# takes a very long time, so run it every 5 minutes
if [ "${0##*/}" = "pr-fetcher-daemon" ] || [ "$1" = "daemon" ]; then
	while true; do
		output=""
		output="$(hub pr list -f '(%i) (%NC) %t by %au%n')"
		[ -z "$output" ] && continue
		printf "%s\\n" "$output" > "${XDG_RUNTIME_DIR:-'/tmp/'}"/PRs
		sleep 300
	done
fi

if [ ! -f "${XDG_RUNTIME_DIR:-'/tmp'}"/PRs ]; then
	echo "PRs file is not present, start pr-fetcher-daemon or run this program with daemon" >&2
	return 1
fi

# Ask the user to pick a PR using 'fzy'
picked_pr="$(grep -v "by $(get-repo-config origin-repo-owner)" < "${XDG_RUNTIME_DIR:-'/tmp'}"/PRs \
			 | fzy --lines="$(tput cols)")"

# If the user picked nothing then quit, this program can be used to check for PRs
[ -z "$picked_pr" ] && return 0

# Number of the PR as a whole integer, remove the () and # with tr
pr_num="$(printf "%s\\n" "$picked_pr" | cut -d ' ' -f1 | tr -d '()#')"
title="$(printf "%s\\n" "$picked_pr" | cut -d ' ' -f3- | sed 's| by .*||g')"

commits=""

# Check if we already reviewed the PR
msg Checking if "$pr_num" "($title)" was already reviewed
reviews="$(hub api \
		   /repos/alpinelinux/aports/pulls/${pr_num}/reviews)"

user="$(printf "%s\\n" "$reviews" \
		| jq --arg GITNAME "$(get-repo-config origin-repo-owner)" \
		 -r '.[].user.login | select(.==$GITNAME)')"
state="$(printf "%s\\n" "$reviews" \
		| jq -r '.[].state')"
body="$(printf "%s\\n" "$reviews" \
		| jq -r '.[].body')"

if [ -n "$user" ]; then
	while true; do
		echo "Previous review found!"
		echo "PR number: $pr_num"
		echo "PR title: $title"
		echo "state: $state"
		echo "body: $body"
		read -p "make new review? " yn
		case $yn in
			[Yy]* ) break ;;
			[Nn]* ) exit 0 ;;
			* ) echo "Please answer yes or no" ;;
		esac
	done
fi

# Check if the pr is already fetched, if not fetch it and checkout it
if git rev-parse --verify "$pr_num" >/dev/null 2>&1; then
	msg Switching to branch "$pr_num"
	gbr "$pr_num"
else
	# Check out the pr num with the name of the pr branch
	msg Fetching and checking out branch "$pr_num"
	hub pr checkout "$pr_num" "$pr_num" >/dev/null 2>&1 &
	msg Fetching commits for "$pr_num"
	commits="$(hub api \
			   /repos/alpinelinux/aports/pulls/${pr_num}/commits \
			   | jq -r '.[].sha' &)"
	wait
fi

if [ -z "$commits" ]; then
	msg Fetching commits from "$pr_num" "($title)"
	commits="$(hub api \
			   /repos/alpinelinux/aports/pulls/${pr_num}/commits \
			   | jq -r '.[].sha')"
fi


# Comments to be given on the PR in regards to commits
commitcomments=""
# Comments to be given on the PR in regards to files changed
filecomments=""
# Comments to be given on the PR in regards to both, comments from the 2 above
# will be added here and displayed to the user
comments=""

# Path to the APKBUILDS that have been changed
files="$(changed_files $(printf "%s\\n" "$commits" | tail -1))"

# Read comments for the PR until we have one that is just exit
for commit in $commits; do
	commitcom="" # The comment on a specific commit
	commit_header="for commit $commit:" # The header used for all comments in a specific commit

	while true; do
		# Show a fzf prompt with the commit navigable as a pager and get the output
		# of the query, either empty or the message to be added to the comments
		# TODO: make it work as a full pager, not matching fuzzy as we type, that is just annoying
		curcom="$(git show "$commit" | colordiff | fzf \
												 --layout reverse \
									 	 		 --ansi \
									 	 		 --print-query \
									 	 		 --no-hscroll \
									 	 		 --border \
									 	 		 --inline-info \
									 	 		 --no-clear \
												 --prompt="$commit > " \
									 	 		 | head -1)"

		# If no output was written on the prompt then the user wants to exit
		# restore the terminal and break out of the loop
		if [ -z "$curcom" ]; then
			tput rmcup
			break
		fi

		# if the commit message is empty then add our current message
		# otherwise add our current message after adding a newline (@@@)
		if [ -z "$commitcom" ]; then
			commitcom="$curcom"
		else
			commitcom="$commitcom@@@$curcom"
		fi
	done

	# If the commit messages are empty then continue, we have nothing to comment
	# on
	if [ -z "$commitcom" ]; then
		continue
	else
		# if the commit comments are empty then add our header and our messages
		# otherwise add the previous commit comments and then add our headers and
		# our messages
		if [ -z "$commitcomments" ]; then
			commitcomments="$commit_header@@@$commitcom"
		else
			commitcomments="$commitcomments@@@ @@@$commit_header@@@$commitcom"
		fi
	fi
done

# Same comments applies here but with files instead of commits
for file in $files; do
	filecom=""
	file_name="for file $file:"

	while true; do
		curcom="$(cat "$file" | fzf \
								--layout reverse \
				  				--ansi \
				  				--print-query \
				  				--no-hscroll \
				  				--border \
				  				--inline-info \
				  				--no-clear \
				  				--prompt="$file > " \
				  				| head -1)"

		if [ -z "$curcom" ]; then
			tput rmcup
			break
		fi

		if [ -z "$filecom" ]; then
			filecom="$curcom"
		else
			# Append our comments.
			filecom="$filecom@@@$curcom"
		fi
	done

	if [ -z "$filecom" ]; then
		continue
	else
		if [ -z "$filecomments" ]; then
			filecomments="$file_name@@@$filecom"
		else
			filecomments="$filecomments@@@ @@@$file_name@@@$filecom"
		fi
	fi
done

# If we have comments about the commits then add them to comments
if [ -n "$commitcomments" ]; then
	comments="$commitcomments"
fi

# If we have comments about the files then add them to files
if [ -n "$filecomments" ]; then
	# If comments is empty then add it, otherwise add it after making
	# a newline and appending the previous comment
	if [ -z "$comments" ]; then
		comments="$filecomments"
	else
		comments="$comments@@@ @@@$filecomments"
	fi
fi

if [ -z "$comments" ]; then
	msg Approving PR "$pr_num" "($title)"
	appr "$pr_num" LGTM
else
	msg Requesting changes on "$pr_num" "($title)" with the following comments "$(printf "%s\\n" "$comments" | sed 's|@@@|\
"|g')"
	appr -r "$pr_num" "$comments"
fi

# Avoid using the 'dlbr' script since that also tries to remove a branch
# in the remote repo and we don't need that
msg Deleting branch "$pr_num"
git checkout -q master && git branch -q -D "$pr_num"
