#!/bin/sh
NORMAL="\033[1;0m"
RED="\033[1;31m"

multiline() {
	echo "$*" | awk '{ printf "%s\\n", $0 }'
}

# https://www.etalabs.net/sh_tricks.html
is_empty() (
	cd "$1" || return 1
	set -- .[!.]* ; test -f "$1" && return 1
	set -- ..?* ; test -f "$1" && return 1
	set -- * ; test -f "$1" && return 1
	return 0 
)

die() {
	_prompt="${RED}>>> ERROR:${NORMAL}"
	printf "$_prompt %s\n" "$1" >&2
	exit 1
}

if [ "$#" -gt 1 ]; then
	tmpdir=$(mktemp -d -t mgmr.XXXXXX)
	# shellcheck disable=2064
	trap "rm -rf '$tmpdir'" INT EXIT

	branch="$(</dev/urandom tr -dc A-Za-z0-9-_ | dd bs=22 count=1 2>/dev/null)"
	git switch --force-create "$branch" master

	for mr in "$@"; do
		mr "$mr" || die "Failed to checkout mr !$mr"
		commits="$(gcp | cut -d ' ' -f 1)"

		# Check if the directory is empty and just write the commits out
		# if it is
		if is_empty "$tmpdir"; then
			echo "$commits" > "$tmpdir"/"$mr"
		else
			# Sort all the commits that are stored in their MRs and get
			# only the unique ones, that should be present only on the
			# last-commited MR.
			sort "$tmpdir"/* | uniq -u > "$tmpdir"/"$mr"
		fi
	done

	mgbr || die "Failed to merge mrs $*"

	for mr in "$@"; do
		close-mr "$mr" & 
		# Read out the mr file for the mr itself, this should contain the commits
		# that were merged
		comment-mr "$mr" 'This was merged on the following commits:

'$(cat "$tmpdir"/"$mr")'

Thanks for your contribution' &
	done
	wait 

else
	checkmr "$1" || die "Failed to check out mr !$1"
	commits="$(gcp | cut -d ' ' -f 1)"
	mgbr || die "Failed to merge mr !$1"
	close-mr "$1" & 
	comment-mr "$1" 'This was merged on the following commits:

'"$commits"'

Thanks for your contribution' &
	wait
fi
