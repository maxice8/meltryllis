#!/bin/sh
NORMAL="\033[1;0m"
RED="\033[1;31m"

multiline() {
	echo "$*" | awk '{ printf "%s\\n", $0 }'
}

# https://www.etalabs.net/sh_tricks.html
is_empty() (
	cd "$1" || return 1
	set -- .[!.]* ; test -f "$1" && return 1
	set -- ..?* ; test -f "$1" && return 1
	set -- * ; test -f "$1" && return 1
	return 0 
)

die() {
	_prompt="${RED}>>> ERROR:${NORMAL}"
	printf "$_prompt %s\n" "$1" >&2
	exit 1
}

if [ "$#" -gt 1 ]; then
	tmpdir=$(mktemp -d -t mgmr.XXXXXX)
	# shellcheck disable=2064
	trap "rm -rf '$tmpdir'" INT EXIT

	branch="$(</dev/urandom tr -dc A-Za-z0-9-_ | dd bs=22 count=1 2>/dev/null)"
	git switch --force-create "$branch" master

	for mr in "$@"; do
		mr "$mr" || die "Failed to checkout mr !$mr"
		commits="$(gcp | cut -d ' ' -f 1)"

		# Write all commits out into the mr file
		echo "$commits" > "$tmpdir"/"$mr"

		# Sort the MR files and get only the unique results
		# which are the newly added commits from the MR we are
		# working on
		commits="$(sort "$tmpdir"/* | uniq -u)"
		
		# Write the commits out in a separate step from the sort | uniq -u
		# just in case there is a problem with shell and it ends up overriding
		# it
		printf "%s\\n" "$commits" > "$tmpdir"/"$mr"
	done

	mgbr || die "Failed to merge mrs $*"

	for mr in "$@"; do
		close-mr "$mr" & 
		# Read out the mr file for the mr itself, this should contain the commits
		# that were merged
		comment-mr "$mr" 'This was merged as the following commits:

'"$(cat "$tmpdir"/"$mr")"'

Thanks for your contribution' &
	done
	wait 

else
	checkmr "$1" || die "Failed to check out mr !$1"
	commits="$(gcp | cut -d ' ' -f 1)"
	mgbr || die "Failed to merge mr !$1"
	close-mr "$1" & 
	comment-mr "$1" 'This was merged as the following commits:

'"$commits"'

Thanks for your contribution' &
	wait
fi
