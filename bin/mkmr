#!/bin/sh
# SPDX-License-Identifier: GPL-3.0-only
# mkmr [BRANCH] ... - mkmr create a merge request

# We need XDG_CACHE_HOME to cache the ID of repositories
: "${XDG_CACHE_HOME:-$HOME/.cache}"

check_bin() {
	if ! type "$1" >/dev/null 2>&1; then
		echo "Failed to find program '$1'"
		exit 1
	fi
}

# Check for binaries we need
check_bin curl secret-tool jq git tee cat printf get-repo-config alpine-stable-prefix echo cut printerr gcp &
wait

while [ $# -gt 0 ]
do
	if [ "$1" = "--assignees" ]
	then
		ASSIGN="$2"
		shift
	elif [ "$1" = "--labels" ]
	then
		LABEL="$2"
		shift
	elif [ "$1" = "--title" ]
	then
		TITLE="$2"
		shift
	elif [ "$1" = "--description" ]
	then
		DESCRIPTION="$2"
		shift
	elif [ "$1" = "--target-branch" ]
	then
		TARGET_BRANCH="$2"
		shift
	elif [ "$1" = "--edit" ]
	then
		EDIT=yes
		check_bin quickedit "${EDITOR:-vi}" rm
	else
		args="$args $1"
	fi
	shift
done

[ -z "$args" ] && args="$(git rev-parse --abbrev-ref HEAD)"

# gitstream is the git remote that i push via SSH
# to alpine, in the future this will be joined into
# upstream which will hold gitlab
if git config remote.gitstream.url >/dev/null; then
	remote=gitstream
elif git config remote.upstream.url >/dev/null; then
	remote=upstream
else
	remote=origin
fi

_get_project_id() {
	repo="$(echo "$1" \
			| sed -e 's|https://||g' -e 's|%2F|.|' \
			| tr '/' '.' )"

	# Create cache directory if it doesn't exist
	[ -d "$XDG_CACHE_HOME"/mkmr ] || mkdir -p "$XDG_CACHE_HOME"/mkmr

	# The project ID is cached, read it out
	if [ -f "$XDG_CACHE_HOME"/mkmr/"$repo" ]; then
		cat "$XDG_CACHE_HOME"/mkmr/"$repo"
		return 0
	fi

	# Call the GitLab API to see the id of the repo and write it to the cache
	curl --silent "$1" | jq '.id // empty' | tee "$XDG_CACHE_HOME"/mkmr/"$repo"

	[ -s "$XDG_CACHE_HOME"/mkmr/"$repo" ] || return 1
}

selectcommit() {
	git log $remote/${TARGET_BRANCH}.."$1" --pretty='%h %s' | fzy | cut -d ' ' -f1
}

title() {
	# If we are pushing against a non-default base then prefix it on the commit msg
	[ "$TARGET_BRANCH" != master ] && printf "%s " "[$(alpine-stable-prefix "$TARGET_BRANCH")]"
	# If they do not give us any value then get the last commit
	git show -s --format=%s "${1:-HEAD}"
}

description() {
	git show -s --format=%b "${1:-HEAD}"
}

upgradecommit() {
	# Check if we have an upgrade commit
	gcp | grep -q ': upgrade to [0-9]'
}

addcommit() {
	# Check if we have a commit that adds a new aport
	gcp | grep -q ': new aport$'
}

movecommit() {
	# Check if we have a commit that moves a package to another repo
	gcp | grep -q ': move from '
}

[ -z "$ASSIGN" ] && ASSIGN=0

mr() {
	if [ -z "$TARGET_BRANCH" ]; then
		if [ -n "$(alpine-stable-prefix "$1")" ]; then
			TARGET_BRANCH="$(alpine-stable-prefix "$1")"-stable
		else
			TARGET_BRANCH=master
		fi
	fi

	git rebase $remote/"$TARGET_BRANCH" >/dev/null 2>&1
	git push -uf origin "$1" >/dev/null 2>&1

	# If the user didn't define the title for us then check if we have
	# more than 1 commit then ask the user to pick a commit for the
	# title. If there is only one commit then just use it
	if [ -z "$TITLE" ]; then
		if [ "$(git rev-list --count "$remote"/"$TARGET_BRANCH".."$1")" -gt 1 ]; then
			COMMIT="$(selectcommit "$1")"
			TITLE="$(title "$COMMIT")"
		else
			TITLE="$(title)"
		fi
	fi

	if [ -z "$DESCRIPTION" ]; then
		if [ "$(git rev-list --count "$remote"/"$TARGET_BRANCH".."$1")" -gt 1 ]; then
			if [ -z "$COMMIT" ]; then
				COMMIT="$(selectcommit "$1")"
			fi
			DESCRIPTION="$(description "$COMMIT")"
		else
			DESCRIPTION="$(description)"
		fi
	fi

	if [ -n "$EDIT" ]; then
		DESCRIPTION="$(quickedit "$DESCRIPTION")"
	fi

	# Special code handling for Alpine Linux
	if [ "$upstream_owner"/"$upstream_repo" = alpine/aports ]; then
		if upgradecommit; then
			if [ -z "$LABEL" ]; then
				LABEL=A-upgrade
			else
				LABEL="$LABEL",A-upgrade
			fi
		fi

		if addcommit; then
			if [ -z "$LABEL" ]; then
				LABEL=A-add
			else
				LABEL="$LABEL",A-add
			fi
		fi

		if movecommit; then
			if [ -z "$LABEL" ]; then
				LABEL=A-move
			else
				LABEL="$LABEL",A-move
			fi
		fi
	fi

	# JSON payload that will be used to create the branch
	BODY="{
		\"id\": \"${origin_owner}%2F${origin_repo}\",
		\"source_branch\": \"$(git rev-parse --abbrev-ref HEAD)\",
		\"remove_source_branch\": true,"

	# If we set labels then append it to body
	if [ -n "$LABEL" ]; then
		BODY="$BODY
		\"labels\": \"$LABEL\","
	fi

	if [ -n "$DESCRIPTION" ]; then
		BODY="$BODY
		\"description\": \"$(printf "%s" "$DESCRIPTION" | awk '{printf  "%s\\n", $0}' )\","
	fi

	BODY="$BODY
		\"target_branch\": \"$TARGET_BRANCH\",
		\"title\": \"$TITLE\",
		\"assignee_id\": \"$ASSIGN\",
		\"target_project_id\": $PROJECT_ID
	}";

	JSON="$(curl -X POST "$ORIGIN_ENDPOINT"/merge_requests \
			--header "PRIVATE-TOKEN: $(secret-tool lookup Path a.o/gitlab/token/mkmr)" \
			--header "Content-Type: application/json" \
			--data "$BODY" --silent)"

	WEB_URL="$(echo "$JSON" | jq '.web_url // empty')"

	if [ -z "$WEB_URL" ]; then
		echo "$JSON" | jq -r .
	else
		echo "$WEB_URL" | tr -d '"'
	fi
}

# Get the host of the GitLab repos we are dealing with
ORIGIN_HOST="$(get-endpoint origin)"
UPSTREAM_HOST="$(get-endpoint gitlab)"

# Extract owner and repo for the origin (us) and the upstream repo
origin_owner="$(printf "%s\\n" "$ORIGIN_HOST" | cut -d / -f 4)"
origin_repo="$(printf "%s\\n" "$ORIGIN_HOST" | cut -d / -f 5)"

upstream_owner="$(printf "%s\\n" "$UPSTREAM_HOST" | cut -d / -f 4)"
upstream_repo="$(printf "%s\\n" "$UPSTREAM_HOST" | cut -d / -f 5)"

# This is the ENDPOINT of the project you forked, if we call this with
# curl we get a JSON payload that describes the repo, including stuff like
# its :id and :name
ORIGIN_ENDPOINT="$(printf "%s\\n" "$ORIGIN_HOST" \
	| cut -d / -f -3)"/api/v4/projects/"$origin_owner"%2F"$origin_repo"

# This is the ENDPOINT of the project itself, we need to get its :id value to
# pass as the 'target_project_id'
UPSTREAM_ENDPOINT="$(printf "%s\\n" "$UPSTREAM_HOST" \
	| cut -d / -f -3)"/api/v4/projects/"$upstream_owner"%2F"$upstream_repo"

PROJECT_ID="$(_get_project_id "$UPSTREAM_ENDPOINT")"

if [ -z "$PROJECT_ID" ]; then
	printerr "Failed to find ID of the project"
	exit 1
fi

for arg in $args
do
	mr "$arg"
done
